pub fn gibo_command(target: &str) -> std::io::Result<String> {
    let output = std::process::Command::new("gibo")
        .arg("dump")
        .arg(target)
        .output()?;

    let stdout = match String::from_utf8(output.stdout) {
        Ok(it) => it,
        Err(err) => return Err(std::io::Error::new(std::io::ErrorKind::InvalidData, err)),
    };
    let stderr = match String::from_utf8(output.stderr) {
        Ok(it) => it,
        Err(err) => return Err(std::io::Error::new(std::io::ErrorKind::InvalidData, err)),
    };
    if stderr.contains("boilerplate not found") {
        return Err(std::io::Error::other(format!(
            "Failed to get {target} from gibo: {stdout}"
        )));
    }
    Ok(stdout)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_gibo_command() {
        let result = gibo_command("C++");
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                println!("{e}");
                unreachable!();
            }
        };
        assert!(result.contains("Generated by gibo"));
        assert!(result.contains("C++"));
    }

    #[test]
    fn test_gibo_command_fail() {
        let result = gibo_command("unknown-language");
        assert!(result.is_err());
    }
}
